---
execute: 
  warning: false
  eval: true
---

# Inference and analysis of gene regulatory networks (GRNs)

In this lesson, you will learn how to infer gene regulatory networks (GRNs)
from bulk RNA-seq data. At the end of the lesson, you will be able to:

- infer GRNs using different popular algorithms
- explore GRNs to extract subgraphs of interest
- visualize GRNs

Let's start by loading the packages we will use.

```{r}
set.seed(123) # for reproducibility

# Load required packages
library(tidyverse)
library(BioNERO)
library(SummarizedExperiment)
library(here)
```

## Getting to know the example data

Here, we will use an example data set available in `data/se_PRJNA800609.rda`
in [the Github repo associated with this course](https://github.com/almeidasilvaf/NASB). 
This experiment comprises soybean (*Glycine max*) pods infected with
the pathogenic fungus *Colletotrichum truncatum*, and data were downloaded from 
[The Soybean Expression Atlas v2](https://soyatlas.venanciogroup.uenf.br/)
[@almeida2023soybean] using the BioProject accession *PRJNA800609*. 
The original data were generated by @zhu2022transcriptomic.

```{r}
# Load expression data
load(here("data", "se_PRJNA800609.rda"))

# Rename object to a simpler name
exp <- se_PRJNA800609
rm(se_PRJNA800609)

# Take a look at the object
exp
```

We will also use soybean transcription factors obtained from 
PlantTFDB 4.0 [@jin2016planttfdb], which are stored in `data/gma_tfs.rda`.

```{r}
# Load transcription factors
load(here("data", "gma_tfs.rda"))

head(gma_tfs)
length(gma_tfs)
```

## GRN inference

To infer GRNs, we need two input objects:

1. A gene expression matrix (or a `SummarizedExperiment` object)
2. A vector of known regulators (e.g., TFs).

First, let's preprocess our expression data with `exp_preprocess()`. 
Here, for the sake of demonstration, we will only use the top 2000 genes
with the highest variances.

```{r}
# Preprocess the input data
final_exp <- exp_preprocess(
    exp,
    min_exp = 5, 
    variance_filter = TRUE, 
    n = 2000
)
```

Now we're good to go. With __BioNERO__, one can infer GRNs using 3 popular
algorithms: GENIE3 [@huynh2010inferring], ARACNE [@margolin2006aracne], 
and CLR [@faith2007large]. Users can also infer GRNs using a combination
of methods (a.k.a. "wisdom of the crowds" principle), which has been shown
to lead to more accurate results [@marbach2012wisdom]. Let's demonstrate each
of these approaches.

### Individual algorithms

To infer GRNs using individual algorithms, you'd use the function
`grn_infer()` and specify the method in the *method* parameter. Below
you can find a short description of each algorithm and how to run them.


**GENIE3:** a regression-tree based algorithm that decomposes the prediction 
of GRNs for *n* genes into *n* regression problems. For each regression 
problem, the expression profile of a target gene is predicted from 
the expression profiles of all other genes using random forests 
(default) or extra-trees.


```{r}
# Infer a GRN with GENIE3
grn_genie3 <- grn_infer(
    final_exp, 
    method = "genie3", 
    regulators = gma_tfs,
    nTrees = 10 # <1>
)

head(grn_genie3)
```
1. Here, for demonstration purposes, we're using only 10 trees, but one should 
use at least 1000 trees (default).


**ARACNE:** information-theoretic algorithm that aims to remove indirect 
interactions inferred by coexpression.

```{r}
# Infer a GRN with ARACNE
grn_aracne <- grn_infer(
    final_exp, 
    method = "aracne", 
    regulators = gma_tfs
)

head(grn_aracne)
```

**CLR:** extension of the relevance networks algorithm that uses mutual 
information to identify regulatory interactions.

```{r}
# Infer a GRN with CLR
grn_clr <- grn_infer(
    final_exp,
    method = "clr",
    regulators = gma_tfs
)

head(grn_clr)
```

Note that these functions return a fully connected graph, so you'll need to
filter the edge list to remove spurious edges. One way to do it is
by removing edges below a particular value for the `Weight` variable. However,
since choosing a cut-off is not straightforward and often arbitrary,
you can use the function `grn_filter()` to perform a graph-based filtering.
Briefly, this function splits the network in *N* subnetworks of increasing
size and calculates the scale-free topology fit for each subgraph. In the end,
the subgraph with the best scale-free topology fit will be chosen as the
optimum. 

This is how you can use it:

```{r}
# Filter the GENIE3-derived GRN based on optimal SFT fit
filtered_grn <- grn_filter(grn_genie3)
head(filtered_grn)
```

::: {.callout-tip}

### Practice

1. Filter the GRN obtained with GENIE3 to keep only edges with weight $\ge$0.2.
Then, answer the questions below:

- What is the top TF in number of targets?
- What genes are regulated by the top TF?

2. What is the rank of the edge *Glyma.07G212400 -> Glyma.10G224500* in all
three networks? What is the mean rank?

::: {.callout appearance="minimal" collapse="true"}

### Show me the solutions

```{r}
# Q1
## top TF
genie3_filt <- grn_genie3[grn_genie3$Weight >= 0.2, ]
head(sort(table(genie3_filt$Node1), decreasing = TRUE))

## targets of the top TF
genie3_filt[genie3_filt$Node1 == "Glyma.06G034000", "Node2"]

# Q2
edge <- c("Glyma.07G212400", "Glyma.10G224500")

rank_genie3 <- which(grn_genie3$Node1 == edge[1] & grn_genie3$Node2 == edge[2])
rank_aracne <- which(grn_aracne$Node1 == edge[1] & grn_aracne$Node2 == edge[2])
rank_clr <- which(grn_clr$Node1 == edge[1] & grn_clr$Node2 == edge[2])

mean(rank_genie3, rank_aracne, rank_clr)
```

:::
:::


### Wisdom of the crowds

The "wisdom of the crowds" principle consists in combining inferences from
multiple methods to obtain robust and more accurate predictions. 
As @marbach2012wisdom stated in their paper:

> We observe that no single inference method performs optimally across all datasets. In contrast, integration of predictions from multiple inference methods shows robust and high performance across diverse datasets.

In __BioNERO__, this is performed by computing average edge ranks across
different networks, exactly as you did in the previous practice problem,
and it can be executed with the function `exp2grn()`. After computing average
ranks for each edge, `exp2grn()` sorts the edges based on ranks (in increasing
order) and uses the graph-based filtering approach (as in `grn_filter()`) to
remove spurious edges.

```{r}
# Infer GRN
grn <- exp2grn(
    exp = final_exp,
    regulators = gma_tfs,
    nTrees = 10 # again, using only 10 trees for demonstration purposes
)

head(grn)
```

::: {.callout-tip}

### Practice

Explore the output of the GRN inferred with `exp2grn()` and answer 
the following questions.

- What regulator has the greatest number of targets?
- What genes are regulated by the top regulator?
- What is the minimum, maximum, mean, and median number of regulators 
per target?

::: {.callout appearance="minimal" collapse="true"}

### Show me the solutions

```{r}
# Q1
head(sort(table(grn$Regulator), decreasing = TRUE))

# Q2
grn[grn$Regulator == "Glyma.15G019400", "Target"]

# Q3
reg_per_target <- grn |>
    group_by(Target) |>
    summarise(Nregs = length(unique(Regulator)))

summary(reg_per_target$Nregs)
```

:::
:::


## GRN analyses

After you have a GRN, there are many things you can do with it. The downstream
analyses you should do will really depend on the question you're trying to
address. Nevertheless, in this section you will see examples of common analyses
people do, but keep in mind that these are not the only ones; you can
(and should) be creative and explore different aspects of the GRN based on your
research project.

### Finding GRN hubs

Finding hubs in GRNs is a very common practice in publications, and the
goal here is to identify the so-called *master regulators* of particular
biological processes. 

This can be performed with the function `get_hubs_grn()`, which returns
the top 10% regulators (adjustable) based on degree.

```{r}
# Find GRN hubs
grn_hubs <- get_hubs_grn(grn)

head(grn_hubs)
```

::: {.callout-tip}

## Practice

What is the minimum, maximum, mean, and median degree for GRN hubs?

::: {.callout appearance="minimal" collapse="true"}

### Show me the solutions

```{r}
summary(grn_hubs$Degree)
```

:::
:::

### Exploring and visualizing GRNs

Another common analysis is to extract subgraphs for a particular group of genes
(usually known to be involved in a process of interest) and plot them.

First, let's plot the entire network. This is feasible here because we 
specifically filtered the expression data to have a small network (for
demonstration purposes), but it is often not feasible in real-world networks.

```{r}
# Plot the entire network
p_all <- plot_grn(grn)

p_all
```

By default, only the top 5 hubs are labeled, but you can change that based
on your preferences. For example:

```{r}
# Label the top 10 hubs
plot_grn(grn, top_n_hubs = 10)

# Hide all labels
plot_grn(grn, show_labels = "none")
```

Now, we will visualize the subgraph for the top hub and its targets. You can do
that by filtering the edge list to keep only edges containing the gene(s) you're
interested (here, the top hub).

```{r}
# Keep only edges containing the top hub
top_hub <- grn_hubs$Gene[1]
edges_top_hub <- grn[grn$Regulator == top_hub, ]

head(edges_top_hub)

# Visualize the subgraph
plot_grn(edges_top_hub)
```

With smaller subgraphs, it's nice to play with parameters in `plot_grn()` to
customize your visualization. For example:

```{r}
# Show all nodes
plot_grn(edges_top_hub, show_labels = "all")
```

Finally, since the output of `plot_grn()` is a ggplot object (same 
for `plot_gcn()` and `plot_ppi()`), you can store it in an object and modify it
later. For example:

```{r}
p_grn <- plot_grn(edges_top_hub)

# Change colors of regulators and targets
p_grn +
    scale_fill_manual(values = c("dodgerblue3", "firebrick3"))

# Remove legend
p_grn +
    theme(legend.position = "none")
```

::: {.callout-tip}

### Practice

Create a subgraph with the top 10 hubs and their targets. Then, create different
network visualizations based on the following instructions:

**Network 1:** Default parameters in `plot_grn()`

**Network 2:** Label all hubs.

**Network 3:** Label all hubs and change node colors (the fill aesthetics) so that
regulators have the colors "black" and targets have the color "grey70".

**Network 4:** Label all hubs and add the following plot title: "Network representation
of the top 10 hubs and their targets"

**Network 5:** Label all hubs, change the network layout function 
to `with_gem`, and move the legend to the bottom of the plot.



::: {.callout appearance="minimal" collapse="true"}

### Show me the solutions

```{r}
edges <- grn[grn$Regulator %in% grn_hubs$Gene[1:10], ]

# 1
plot_grn(edges)

# 2
plot_grn(edges, show_labels = "allhubs")

# 3
plot_grn(edges, show_labels = "allhubs") +
    scale_fill_manual(values = c("grey70", "black"))

# 4
plot_grn(edges, show_labels = "allhubs") +
    labs(title = "Network representation of the top 10 hubs and their targets")

# 5
plot_grn(edges, show_labels = "allhubs", layout = igraph::with_gem) +
    theme(legend.position = "bottom")
```

:::
:::






## Session information {.unnumbered}

This chapter was created under the following conditions:

```{r}
#| echo: false
sessioninfo::session_info()
```

## References {.unnumbered}


