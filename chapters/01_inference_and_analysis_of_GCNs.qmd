---
execute: 
  warning: false
---

# Inference and analysis gene coexpression networks (GCNs)

In this lesson, you will learn how to infer and analyze gene coexpression 
networks (GCNs) from bulk RNA-seq data. At the end of this lesson, 
you will be able to:

- preprocess your quantitative data for GCN inference
- infer a GCN that is best suitable for your project goals
- identify genes with increased/decreased expression profiles in conditions of
interest
- perform a functional profiling of interesting coexpression modules
- explore and visualize subgraphs


Let's start by loading the packages we will use.

```{r}
set.seed(123) # for reproducibility

# Load required packages
library(tidyverse)
library(BioNERO)
library(SummarizedExperiment)
library(here)
```

## Getting to know the example data

Here, we will use an example data set available in `data/se_PRJNA800609.rda`
in [the Github repo associated with this course](https://github.com/almeidasilvaf/NASB). 
This experiment comprises soybean (*Glycine max*) pods infected with
the pathogenic fungus *Colletotrichum truncatum*, and data were downloaded from 
[The Soybean Expression Atlas v2](https://soyatlas.venanciogroup.uenf.br/)
[@almeida2023soybean] using the BioProject accession *PRJNA800609*. 
The original data were generated by @zhu2022transcriptomic.

```{r}
# Load expression data
load(here("data", "se_PRJNA800609.rda"))

# Rename object to a simpler name
exp <- se_PRJNA800609
rm(se_PRJNA800609)

# Take a look at the object
exp
```

As you can see, the expression data are stored in a `SummarizedExperiment`
object, which is a standard data class in Bioconductor to represent
quantitative data. The advantage of `SummarizedExperiment` objects over
simple matrices or data frames is that they can store in a single object:

- The matrix (or matrices) with quantitative data, with features (e.g., genes,
transcripts, etc.) in rows and samples in columns - accessed with `assays()`.
- Sample metadata (e.g., treatments, tissues, etc.) - accessed with `colData()`.
- Gene metadata (e.g., functional annotation) - accessed with `rowData()`.
- Experiment metadata, with details on study design - accessed with `metadata()`.


![Anatomy of a *SummarizedExperiment* object](summarizedExperiment.svg)

Now, let's take a look at the data.

```{r}
# Access the expression matrix
head(assay(exp))

# Access sample metadata (i.e., colData)
colData(exp)
```

::: {.callout-tip}

### Practice

Explore the `exp` object to answer the questions below:

1. How many levels are there for the `Treatment` variable?
2. Subset the expression data to keep only treated samples and calculate 
the mean expression for each gene. What is the ID of the gene with the 
greatest mean expression in treated samples? Tip: use the `rowMeans()`
function to calculate means for all genes.


::: {.callout appearance="minimal" collapse="true"}

### Show me the solutions

```{r}
# Q1
table(exp$Treatment)

# Q2
treated <- exp[, exp$Treatment == "infected"]
gene_means <- rowMeans(assay(treated))
sort(gene_means, decreasing = TRUE)[1]
```

:::
:::


## Data preprocessing

Before inferring a GCN, we have to filter and transform our expression data to
maximize biological signal. The preprocessing functions implemented in 
__BioNERO__ can help users:

1. Handle missing values - `replace_na()`;
2. Remove non-expressed/lowly expressed genes - `remove_nonexp()`;
3. Remove genes with low variances in expression levels - `filter_by_variance()`;
4. Filter outlying samples - `ZKfiltering()`;
5. Apply a principal component-based correction for confounders - `PC_correction()`.

These preprocessing steps are optional, but strongly recommended. To execute 
them, you can either run one function after another (recommended if you want
to use a few, but not all preprocessing steps), or use the wrapper function
`exp_preprocess()`, as demonstrated below.

::: {.column-page}
::: {.columns}
::: {.column width="45%"}

**Step-by-step processing**

This is how you can preprocess your expression data by piping one function
after another using R's native pipe operator (`|>`):

```{r}
final_exp1 <- exp |>                                    # <1>
    BioNERO::replace_na() |>                                     # <2>
    remove_nonexp(method = "median", min_exp = 5) |>    # <3>
    filter_by_variance(percentile = 0.2) |>             # <4>
    PC_correction()                                     # <5>
```
1. Take `exp`, and then
2. replace missing values (`NA`) with 0, and then
3. remove genes with median expression <5, and then
4. keep only the top 20% of the genes with highest variances, and then
5. correct for confounders and apply quantile normalization.

:::

::: {.column width='3%'}

:::

::: {.column width="45%"}

**One-step processing**

To preprocess your expression data in a single function, use the
function `exp_preprocess()`.

```{r}
final_exp2 <- exp_preprocess(
    exp, 
    min_exp = 5,
    variance_filter = TRUE,
    percentile = 0.2,
    Zk_filtering = FALSE
)
```

:::
:::
:::

Both examples above lead to the same results, so they are simply two different
ways of executing the same task. 

::: {.callout-tip}

### Practice

1. Compare the objects `final_exp1` and `final_exp2` to verify that they
are indeed the same.


2. After correcting for confounders with `PC_correction()`, the expression
data are quantile-normalized so that the expression levels for all genes
are normally distributed. Visualize the distribution of expression levels
for a few genes to verify that.

::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r}
# Q1
## Are dimensions (number of rows and columns) identical?
identical(dim(final_exp1), dim(final_exp2))

## Are the processed expression matrices identical?
identical(
    assay(final_exp1)[1:5, 1:5],
    assay(final_exp2)[1:5, 1:5]
)

# Q2
hist(assay(final_exp1)[1, ])
```


:::

:::

## Exploratory data analyses

Once you have your processed expression data, you can check if they
look as expected by visually exploring:

- heatmaps (gene expression or sample correlations) - `plot_heatmap()`.
- principal component analysis (PCA) - `plot_PCA()`

First, let's take a look at pairwise sample correlations.

```{r}
# Plot pairwise sample correlations
p_heatmap <- plot_heatmap(
    final_exp1, 
    type = "samplecor", 
    coldata_cols = "Treatment",
    show_rownames = FALSE,
    show_colnames = FALSE
)

p_heatmap
```

Now, let's plot a principal component analysis of samples.

```{r}
# Plot PCA
p_pca <- plot_PCA(
    final_exp1,
    metadata_cols = "Treatment",
)

p_pca
```

::: {.callout-tip}

### Practice

1. Recreate the heatmap of sample correlations, but now add individual legends
for the variables `Cultivar` and `Timepoint`.

2. Create a PCA plot showing the 1st and 3rd principal components.

::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r}
# Q1
plot_heatmap(
    final_exp1, 
    type = "samplecor", 
    coldata_cols = c("Treatment", "Cultivar", "Timepoint"),
    show_rownames = FALSE,
    show_colnames = FALSE
)

# Q2
plot_PCA(
    final_exp1,
    metadata_cols = "Treatment",
    PCs = c(1, 3)
)
```

:::

:::


## Gene coexpression network inference

Before inferring the GCN, we must first select a value for the power $\beta$
to which correlation coefficients will be raised. Raising correlations to a
power $\beta$ aims at amplifying their distances and, hence, making
module detection more powerful. Greater values of $\beta$ makes the network
resemble more a scale-free network, but at the cost of reducing the mean
connectivity. To solve this trade-off, we will use the function `SFT_fit()`.

```{r}
# Find optimal beta power to which correlation coefficients will be raised
sft <- SFT_fit(
    final_exp1, 
    net_type = "signed hybrid", # <1>
    cor_method = "pearson"      # <2>
)

sft$power
sft$plot
```
1. Infer a *signed hybrid* network (negative correlations are represented as 0).
2. Use Pearson's correlation coefficient.


Next, we can use the estimated $\beta$ power to infer a GCN with `exp2gcn()`.

```{r}
# Infer a GCN
gcn <- exp2gcn(
    final_exp1, 
    net_type = "signed hybrid",
    SFTpower = sft$power,
    cor_method = "pearson"
)

names(gcn)
```

The output of the `exp2gcn()` function is a list with the following elements:

1. `adjacency_matrix`: a square matrix $m_{ij}$ representing representing the 
strength of the connection between gene *i* and gene *j*.
2. `correlation_matrix`: very similar to `adjacency_matrix`, but values inside the
matrix represent correlation coefficients.
3. `genes_and_modules()`: a 2-column data frame of genes and their corresponding
modules.
4. `MEs`: a data frame with module eigengenes (i.e., a summary of each module's
expression profiles).
5. `kIN`: a data frame with each gene's degrees (i.e., sum of connection 
weights), both with genes inside the same module and in different modules.
6. `params`: list of parameters used for network inference.
7. `dendro_plot_objects`: list of objects used to plot a dendrogram of genes
and modules with `plot_dendro_and_colors()`.

::: {.callout-tip}

### Practice

Explore the object `gcn` to answer the following questions:

1. How many modules are there?
2. What is the intramodular degree of the gene *Glyma.15G171800*?
3. What is the correlation coefficient of the gene pair 
*Glyma.15G158200*-*Glyma.15G158400*?
4. The **grey** module is not actually a real module; it contains genes that 
could not be assigned to any other module, so it's basically a trash bin. 
How many genes are in this module? 

::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r}
# Q1: number of modules
unique(gcn$genes_and_modules$Modules)

# Q2: intramodular degree of Glyma.15G171800
gcn$kIN["Glyma.15G171800", "kWithin"]

# Q3: correlation coefficient between Glyma.15G158200 and Glyma.15G158400
gcn$correlation_matrix["Glyma.15G158200", "Glyma.15G158400"]

# Q4: number of genes in the grey module
gcn$genes_and_modules |> dplyr::filter(Modules == "grey") |> nrow()
```

:::

:::

## Visual summary of the inferred coexpression modules

First, you'd want to visualize the number of genes per module. This can be
achieved with the function `plot_ngenes_per_module()`.

```{r fig.width=10, fig.height=6}
plot_ngenes_per_module(gcn)
```

Next, you can visualize a heatmap of pairwise correlations between
module eigengenes with `plot_eigengene_network()`.

```{r}
#| fig-height: 6
#| fig-width: 7
plot_eigengene_network(gcn)
```

## Identifying module-trait associations

```{r}
# Calculating module-trait correlations
me_trait <- module_trait_cor(
    exp = final_exp1,
    MEs = gcn$MEs,
    metadata_cols = c("Treatment", "Cultivar", "Timepoint")
)

# Taking a look at the results
head(me_trait)
```

The results of `module_trait_cor()` can be visualized with 
`plot_module_trait_cor()` as follows:

```{r fig.height=6, fig.width=8}
#| fig-height: 6
#| fig-width: 8
plot_module_trait_cor(me_trait)
```

The plot shows that the module **grey60** is positively correlated with
the infected state, which means that genes in this module have increased 
expression levels in infected samples. We can take a closer look at 
this module's expression profile using the 
function `plot_expression_profile()`.

```{r}
plot_expression_profile(
    exp = final_exp1, 
    net = gcn,
    modulename = "grey60",
    metadata_cols = "Treatment"
)
```

::: {.callout-warning icon="false"}

### Challenge

Create a multi-panel figure showing the expression profiles of the four
modules with the highest absolute correlations (sign must be ignored) with
the *infected* state of the variable `Treatment`. For that, use the following
steps:

1. Filter the data frame `me_trait` to include only correlations between
modules and `infected`;
2. Arrange the rows in descending order based on the absolute value of `cor`;
3. Extract the name of the top 4 modules.
4. Iterate (with `lapply()` or a for loop) through each module name and
create a plot with `plot_expression_profile()`;
5. Combine the plots into a multi-panel figure using the `wrap_plots()` 
function from the `r BiocStyle::CRANpkg("patchwork")` package.


::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r fig.height=6, fig.width=9}
#| fig-height: 6
#| fig-width: 9

# Get top modules (based in correlation with `infected`)
modules <- me_trait |>
    filter(trait == "infected") |>
    arrange(-abs(cor)) |>
    slice_head(n = 4) |> 
    mutate(ME = str_replace_all(ME, "ME", "")) |>
    pull(ME)

# Create a list of plots
profile_plots <- lapply(modules, function(x) {
    p <- plot_expression_profile(
        exp = final_exp1, 
        net = gcn,
        modulename = x,
        metadata_cols = "Treatment"
    )
    return(p)
})

# Combine plots with patchwork
p <- patchwork::wrap_plots(
    profile_plots, nrow = 2, ncol = 2
) +
    patchwork::plot_layout(guides = "collect") &
    theme(legend.position = "bottom")

p
```

:::

:::

## Functional analyses of coexpression modules

Once you have identified interesting modules, you'd typically want to explore
the function of the genes therein. This can be done with the function
`module_enrichment()`, which will perform an overrepresentation analysis
for functional terms (e.g., pathways, Gene Ontology terms, etc). 

For that, you need to pass a data frame with genes and their associated
functional annotation as follows:

```{r}
# Load annotation data - this is a list of data frames
load(here("data", "gma_annotation.rda"))

# Taking a look at the data
names(gma_annotation)

head(gma_annotation$MapMan)
head(gma_annotation$InterPro)
```

Then, you can perform the enrichment analyses with:

```{r}
sea_mapman <- module_enrichment(
    net = gcn, 
    background_genes = rownames(final_exp1), # <1>
    annotation = gma_annotation$MapMan       # <2>
)
```
1. Using only genes in the network as background set (very important!)
2. Perform enrichment for MapMan pathways


The output of `module_enrichment()` is a data frame with significant terms
for each module (if any).

```{r}
head(sea_mapman)
```

::: {.callout-tip}

### Practice

1. Inspect the enrichment results in `sea_mapman` and answer the following
questions:

- How many modules had enriched terms? 
- What proportion of the total number of modules does that represent?

2. Rerun the enrichment analysis, but now using the annotation data frame
in `gma_annotation$InterPro`. Then, answer the questions below:

- How many modules had enriched terms?
- What proportion of the total number of modules does that represent?
- Were the number of modules with enriched terms different when using
MapMan annotation and InterPro annotation? If so, why do you think that
happened?

3. (Optional, advanced) Choose one of the interesting modules you found in 
the previous section (on module-trait correlations) and look at 
the enrichment results for it. Based on the expression profiles and 
enrichment results, can you come out with a reasonable biological explanation 
for the observed expression patterns?


::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r}
# Q1
length(unique(sea_mapman$module))
length(unique(sea_mapman$module)) / length(unique(gcn$genes_and_modules$Modules))

# Q2
sea_interpro <- module_enrichment(
    net = gcn, 
    background_genes = rownames(final_exp1),
    annotation = gma_annotation$InterPro
)

length(unique(sea_interpro$module))
length(unique(sea_interpro$module)) / length(unique(gcn$genes_and_modules$Modules))
```

:::
:::

## Identifying hub genes and visualizing networks

Hubs are the genes with the highest degree (i.e., sum of connection weights)
in each module, and they are often considered to be the most important genes
in a network. To identify hubs in a GCN, you can use the 
function `get_hubs_gcn()`.

```{r}
hubs <- get_hubs_gcn(exp = final_exp1, net = gcn)

head(hubs)
```

Besides exploring the major genes in each module, you can use the output
of `get_hubs_gcn()` for network visualization. For that, you will first
need to extract a subgraph containing the genes you want to 
visualize (usually an entire module), which can be achieved with the 
function `get_edge_list()`.

```{r}
edges <- get_edge_list(
    net = gcn,
    module = "royalblue",    # <1>     
    filter = TRUE         # <2>
)

head(edges)
```
1. Create a subgraph containing all genes in the *royalblue* module.
2. Filter the graph to keep only connections greater than or equal to a given
correlation coefficient (automatically estimated based on optimal scale-free
topology fit).


Next, you can use the function `plot_gcn()` to visualize these genes.

```{r}
plot_gcn(
    edgelist_gcn = edges,
    net = gcn,
    color_by = "module", # <1>
    hubs = hubs
)
```
1. Nodes will be colored by their module (hence, in this case, they will
have a single color).

::: {.callout-tip}

### Practice

1. Recreate the edge list for the *royalblue* module, but now 
use `method = 'min_cor'` and `rcutoff = 0.4`. Then, plot the network. 
Does that change the network? If so, how?

2. Visualize the network from the previous question in the interactive mode.


::: {.callout collapse="true" appearance="minimal"}

### Show me the solutions

```{r}
# Q1
fedges <- get_edge_list(
    net = gcn,
    module = "royalblue",
    filter = TRUE,
    method = "min_cor",
    rcutoff = 0.4
)

plot_gcn(
    edgelist_gcn = fedges,
    net = gcn,
    color_by = "module",
    hubs = hubs
)

# Q2
# Note: this part was commented so that this book can be exported to PDF

# plot_gcn(
#     edgelist_gcn = fedges,
#     net = gcn,
#     color_by = "module",
#     hubs = hubs,
#     interactive = TRUE
# )
```

:::
:::


## Session information {.unnumbered}

This chapter was created under the following conditions:

```{r}
#| echo: false
sessioninfo::session_info()
```


## References {.unnumbered}
